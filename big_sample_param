library (jsonlite)



library(plyr) # библиотека необходима для использования rbind.fill 
# склеивания таблиц "одна под другой" при условии разного количесвтва колонок и навзаний колонок

BD <-  fromJSON( sprintf("[%s]",
                         paste(readLines("C:/Users/msmirnov/Documents/проект УСН/Анализ данных/big_chunk_1_new.json", encoding = "UTF-8"),
                               collapse=",")), flatten = TRUE)


system.time({

for (i in  2:10) {
  
  file_name<-paste("C:/Users/msmirnov/Documents/проект УСН/Анализ данных/big_chunk_", i, "_new.json", sep="")
  
  BD_i<- fromJSON( sprintf("[%s]",
                          paste(readLines(file_name, encoding = "UTF-8"),
                                collapse=",")), flatten = TRUE)

  BD<- rbind.fill(BD, BD_i)
  
}

})


# перечень полей и типов 

library(dplyr)


coltypes<-BD[1,] %>% 
  summarise_all(typeof)



coltypes_sample<-rbind(coltypes, BD[835137,])



tt<- as.data.frame(t(coltypes_sample))











# счетчик пустых массивов в поле content.item
countEmptyArrays <- 0

# вектор признаков массив пустой =1 или непустой =0
vec <- c(1:nrow(BD))

for (i in  1:nrow(BD)) {
  
  countEmptyArrays<- countEmptyArrays + ifelse (is.null(unlist(BD[i,24])), 1, 0)
  vec [i]<- is.null(unlist(BD[i,24]))
  
}

# количество чеков с пустым массивом в поле items
countEmptyArrays

# добавляем колонку с признаками "пустого массива" в поле "items" в чеке 
dat3<- cbind(BD, vec)


# остортированная таблица с пустыми чеками в поле items
emptyItemsChecks <- subset(dat3, dat3[,ncol(dat3)]==1) 

# отсортированная таблица с чеками с непустым массивом в содержании (может не быть нвзания позиций. но есть сумма проч.)
fullChecks <- subset(dat3, dat3[,ncol(dat3)]==0)



#инициализируем массив с навзаниями полей в чеке
colNamesArray<-as.data.frame(colnames(as.data.frame(fullChecks[1,24])))
colnames(colNamesArray)<- "colNamesEl"

# fullChecks - весь массив с чеками, у который ittems != NULL
# собираем в таблицу "colNamesArray" содержимое названий всех полей всех чеков
# с помощью union из библиотеки dplyr (см. dplyr cheat sheet)
for (i in  2:nrow(fullChecks)) {
  
  
  colNamesEl<-colnames(as.data.frame(fullChecks[i,24]))
  
  colNamesEl <- as.data.frame(as.data.frame(colNamesEl))
  
  colNamesArray<-union(colNamesArray, colNamesEl) # функция из dplyr, получаем все навзания строк при join 
  
}





grep("fiscalDocumentFormatVer", colnames(BD))
grep("protocolVer", colnames(BD))
grep("j1060", colnames(BD))

tt1<- subset(BD,  !is.na(BD[,75])) # чеки с заполненным "fiscalDocumentFormatVer"



# виды протоколов и их количество в поле "content.fiscalDocumentFormatVer"
head(BD%>%
       select(one_of(c("content.fiscalDocumentFormatVer")))%>%
       group_by(content.fiscalDocumentFormatVer)%>%
       count(content.fiscalDocumentFormatVer)%>%
       arrange(desc(n)),20)



# поле CreditSum не NA и в чеке более 1-й позиции
# Subs1<-subset(BD, (!is.na(BD[,32]))) # & nrow(as.data.frame(BD[,24]))>1)
# 
# Subs2<- subset(Subs1, Subs1[,32]>0)

Subs3<- subset( BD, BD[,32]>0)  


fun<- function(x) { grep("paymentType", colnames(as.data.frame(x)))
  
}

#колонка, в чеке, в которой находится paymentType
Subs3$PayTypeColnum<-sapply(Subs3[,24],  fun)


#признак, если хотя бы одна позиция в чеке имеет paymentType 5 или 6
for (i in  1:nrow(Subs3)) {
  
  Subs3$PaymentType5[i]<-ifelse( 5%in% as.data.frame(Subs3[i,24]) [,unlist(Subs3$PayTypeColnum[i])] || 
                                   6%in% as.data.frame(Subs3[i,24]) [,unlist(Subs3$PayTypeColnum[i])], 1, 0) 
  
}

# сортируем 
Subs4<- subset( Subs3,   Subs3$PaymentType5==1 )  





  
  
# allPaymentTypes<-0
# 
# for (i in  1:nrow(Subs4)) {
# allPaymentTypes<-append(allPaymentTypes, unlist(as.data.frame(Subs3[i,24])[,unlist(Subs3$PayTypeColnum[i])]))
# 
# }





# сортировка чеков creditSum >0 и кол-во Items >1

fun2<- function(x) { nrow(as.data.frame(x))
  
}

Subs3$posNum<-sapply(Subs3[,24], fun2)

BD$posNum<-sapply(BD[,24], fun2)

#кол-во позиций в чеке
Subs4$posNum<-sapply(Subs4[,24], fun2)

Subs4_pos<-subset(Subs4, Subs4$posNum>1)

Subs5<-subset(Subs3, Subs3$posNum>1)


Subs6<- subset( BD,   BD[,23]<0) 
     



colnames_BD<- as.data.frame(colnames(BD))

# уникальные поля в Subtype
uniq_subtypes<-as.data.frame(unique(BD$subtype))







##############################

BD_checks_inside<- BD

bankAgentRemuneration


# функция, возвращающая TRUE если выполняется условие, когда все значения вектора со строковыми переменными присутствуют в названиях колонок чека
fun_ag<-function(x) { 
  all(sapply(as.data.frame(
  
  sapply(c("bso","corr"), grepl, colnames(as.data.frame(x)), ignore.case=TRUE)
  
  ), any)) }

# сортируем массив, применяя функцию ко всем рядам исходдно data.frame
BD_AgentData<- subset(BD_checks_inside, sapply(BD_checks_inside[,24],  fun_ag))


###########################################################################
# по количеству позиций в чеках статистика
summary(BD$posNum)


hist(head(subset(BD$content.totalSum, !is.na(BD$content.totalSum))))


hist(subset(BD$content.totalSum, !is.na(BD$content.totalSum))[ c(1:1000000)], ylim=c(0,5))

# гистограмма чеков без макс значения (сумма 3 572 355 870 руб - техническая нисправность)
hist(subset(BD$content.totalSum, !is.na(BD$content.totalSum)[ c(1:1000000)] & BD$content.totalSum <3572355870), ylim=c(0,20))
hist(subset(BD$content.totalSum, !is.na(BD$content.totalSum)[ c(1:1000000)] & BD$content.totalSum <100000), breaks =10, xlim=c(0,120000), ylim=c(0,400000))
hist(subset(BD$content.totalSum, !is.na(BD$content.totalSum)[ c(1:1000000)] & BD$content.totalSum >=100000 & BD$content.totalSum <120000000), 
     breaks =5000, xlim=c(0,1000000), ylim=c(0,30000))
hist(subset(BD$content.totalSum, !is.na(BD$content.totalSum)[ c(1:1000000)] & BD$content.totalSum >=120000000 ), 
     breaks =150, xlim=c(150000000,400000000), ylim=c(0,10))

boxplot(subset(BD$content.totalSum, !is.na(BD$content.totalSum) & BD$content.totalSum <100000))

max(subset(BD$content.totalSum, !is.na(BD$content.totalSum)))

subset(BD, BD$content.totalSum==3572355870)

BD_closeShif<-(subset(BD, BD$subtype=="closeShift"))
